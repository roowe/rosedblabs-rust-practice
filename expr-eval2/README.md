# 四则运算表达式求值器

一个用 Rust 实现的完整表达式求值器，支持四则运算、幂运算、括号和正确的运算符优先级与结合性处理。

## ✨ 特性

- 🔢 支持整数四则运算（+、-、*、/）
- 🔺 支持幂运算（^）
- 📐 支持括号改变运算优先级
- ⚖️ 正确处理运算符的左结合和右结合
- 🛡️ 完善的错误处理
- 🎯 三种不同的实现方法

## 🚀 快速开始

```bash
# 克隆项目
git clone <your-repo-url>
cd expr-eval2

# 运行项目
cargo run
```

## 📖 支持的表达式

```rust
"92 + 5 + 5 * 27 - (92 - 12) / 4 + 26"  // 复合表达式
"2 + 3 * 4"                             // 优先级：14
"(2 + 3) * 4"                           // 括号改变优先级：20
"2 * (3 + 4)"                           // 括号：14
"10 - 5 - 2"                            // 左结合：3
"8 / 4 / 2"                             // 左结合：1
"2^3^2"                                 // 右结合：512 (2^9)
"4^3^2"                                 // 右结合：262144 (4^9)
```

## 🏗️ 三种实现方法

### 方法1：递归下降解析器（推荐）

**核心思想**：使用优先级爬升算法，递归解析表达式

```rust
fn compute_expr(&mut self, min_prec: u8) -> Result<i32>
fn compute_atom(&mut self) -> Result<i32>
```

**优势**：
- ✅ 代码结构清晰，易于理解和维护
- ✅ 扩展性强，添加新操作符简单
- ✅ 错误处理精确
- ✅ 内存效率高

**适用场景**：生产环境、需要扩展的解析器

### 方法2：调度场算法（Shunting Yard）

**核心思想**：先将中缀表达式转换为后缀表达式，再求值

```rust
中缀表达式 → 后缀表达式 → 计算结果
"2 + 3 * 4" → "2 3 4 * +" → 14
```

**优势**：
- ✅ 经典算法，理论基础扎实
- ✅ 分离解析和计算逻辑
- ✅ 后缀表达式可重用
- ✅ 无递归限制

**适用场景**：学习算法、需要生成中间表示

### 方法3：直接求值双栈

**核心思想**：使用数字栈和操作符栈，边解析边计算

```rust
let mut num_stack: Vec<i32> = Vec::new();    // 数字栈
let mut op_stack: Vec<char> = Vec::new();    // 操作符栈
```

**优势**：
- ✅ 一次遍历，效率最高
- ✅ 内存占用最少
- ✅ 算法直观易懂
- ✅ 适合流式处理

**适用场景**：性能要求高、资源受限环境

## 🔧 括号处理原理

### 左括号 `(`
- 直接压入操作符栈
- 作为"屏障"，阻止与前面操作符的优先级比较

### 右括号 `)`
- 不断弹出并计算操作符，直到遇到对应的左括号
- 弹出左括号（但不参与计算）

```rust
// 示例：(2 + 3) * 4
// 1. 遇到 '('：压入操作符栈 [('']
// 2. 解析 2 + 3：在括号内正常计算
// 3. 遇到 ')'：计算得到 5，弹出 '('
// 4. 继续处理 * 4：最终得到 20
```

## ⚖️ 结合性处理

### 左结合（+、-、*、/）
```rust
"a - b - c" = "(a - b) - c"
// 规则：当前优先级 ≤ 栈顶优先级时，先计算栈顶
```

### 右结合（^）
```rust
"a ^ b ^ c" = "a ^ (b ^ c)"
// 规则：当前优先级 < 栈顶优先级时，先计算栈顶
```

## 📊 性能对比

| 特性 | 递归下降 | 调度场算法 | 直接双栈 |
|------|----------|------------|----------|
| **时间复杂度** | O(n) | O(n) | O(n) |
| **空间复杂度** | O(递归深度) | O(n) | O(操作符数) |
| **代码复杂度** | 中等 | 高 | 高 |
| **扩展性** | 优秀 | 良好 | 一般 |
| **错误处理** | 优秀 | 良好 | 一般 |
| **学习难度** | 中等 | 高 | 低 |

## 🎯 运算符优先级

```rust
优先级 3: ^ (幂运算，右结合)
优先级 2: *, / (乘除，左结合)  
优先级 1: +, - (加减，左结合)
```

## 🧪 测试用例

运行程序会自动测试以下表达式：

```rust
let test_cases = vec![
    "92 + 5 + 5 * 27 - (92 - 12) / 4 + 26",
    "2 + 3 * 4",
    "(2 + 3) * 4", 
    "2 * (3 + 4)",
    "((2 + 3) * 4 - 1) / 3",
    "10 - 5 - 2",     // 左结合测试
    "8 / 4 / 2",      // 左结合测试
    "2^3^2",          // 右结合测试
    "4^3^2",          // 右结合测试
];
```

## 🛠️ 项目结构

```
expr-eval2/
├── src/
│   └── main.rs          # 主要实现文件
├── Cargo.toml           # 项目配置
├── Cargo.lock           # 依赖锁定
└── README.md            # 项目文档
```

## 📚 核心代码结构

```rust
// 错误类型定义
pub enum ExprError {
    Parse(String),
}

// Token 定义
enum Token {
    Number(i32),
    Plus, Minus, Multiply, Divide, Power,
    LeftParen, RightParen,
}

// 三种实现
fn shunting_yard_evaluate(expr: &str) -> Result<i32>  // 调度场算法
fn direct_evaluation(expr: &str) -> Result<i32>       // 直接双栈
struct Expr<'a>                                       // 递归下降解析器
```

## 🔍 学习要点

1. **理解运算符优先级**：* / 比 + - 优先级高
2. **掌握结合性概念**：左结合 vs 右结合的区别
3. **括号处理技巧**：如何用栈处理嵌套括号
4. **三种算法思路**：递归、转换、直接计算的权衡
5. **错误处理**：如何优雅地处理解析错误

## 🤝 贡献

欢迎提交 Issue 和 Pull Request！

## 📄 许可证

MIT License

---

*这个项目展示了表达式求值的三种经典方法，是学习编译原理和算法设计的绝佳实践项目。*
